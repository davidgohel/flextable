#' @export
#' @title fit a flextable to a maximum width
#' @description decrease font size for each cell incrementally until
#' it fits a given max_width.
#' @param x flextable object
#' @param max_width maximum width to fit in inches
#' @param inc the font size decrease for each step
#' @param max_iter maximum iterations
#' @param unit unit for max_width, one of "in", "cm", "mm".
#' @examples
#' ft_1 <- qflextable(head(mtcars))
#' ft_1 <- width(ft_1, width = 1)
#' ft_1
#'
#' ft_2 <- fit_to_width(ft_1, max_width = 4)
#' ft_2
#' @family flextable dimensions
#' @section Illustrations:
#'
#' \if{html}{\figure{fig_fit_to_width_1.png}{options: width="400"}}
#'
#' \if{html}{\figure{fig_fit_to_width_2.png}{options: width="150"}}
fit_to_width <- function(x, max_width, inc = 1L, max_iter = 20, unit = "in" ){
  max_width <- convin(unit = unit, x = max_width)

  go <- TRUE
  while(go){
    fdim <- flextable_dim(x)

    if( fdim$widths > max_width){
      if( nrow_part(x, part = "body") > 0 )
        x$body$styles$text$font.size$data[] <- x$body$styles$text$font.size$data - inc
      if( nrow_part(x, part = "footer") > 0 )
        x$footer$styles$text$font.size$data[] <- x$footer$styles$text$font.size$data - inc
      if( nrow_part(x, part = "header") > 0 )
        x$header$styles$text$font.size$data[] <- x$header$styles$text$font.size$data - inc

      x <- autofit(x, add_w = 0.0, add_h = 0.0)
    } else go <- FALSE
  }
  x
}


#' @export
#' @title Set flextable columns width
#' @description control columns width
#' @param x flextable object
#' @param j columns selection
#' @param width width in inches
#' @param unit unit for width, one of "in", "cm", "mm".
#' @details
#' Heights are not used when flextable is been rendered into HTML.
#' @examples
#'
#' ft <- flextable(head(iris))
#' ft <- width(ft, width = 1.5)
#' ft
#' @family flextable dimensions
#' @section Illustrations:
#'
#' \if{html}{\figure{fig_width_1.png}{options: width="400"}}
width <- function(x, j = NULL, width, unit = "in"){

  width <- convin(unit = unit, x = width)
  j <- get_columns_id(x[["body"]], j )

  stopifnot(length(j)==length(width) || length(width) == 1)

  if( length(width) == 1 ) width <- rep(width, length(j))

  x$header$colwidths[j] <- width
  x$footer$colwidths[j] <- width
  x$body$colwidths[j] <- width

  x
}

#' @export
#' @title Set flextable rows height
#' @description control rows height for a part of the flextable when the line
#' height adjustment is "atleast" or "exact" (see [hrule()]).
#' @note
#' This function has no effect when the rule for line height is set to
#' "auto" (see [hrule()]), which is the default case, except with PowerPoint
#' which does not support this automatic line height adjustment feature.
#' @param x flextable object
#' @param i rows selection
#' @param height height in inches
#' @param unit unit for height, one of "in", "cm", "mm".
#' @param part partname of the table
#' @examples
#' ft_1 <- flextable(head(iris))
#' ft_1 <- height(ft_1, height = .5)
#' ft_1 <- hrule(ft_1, rule = "exact")
#' ft_1
#' @family flextable dimensions
#' @section Illustrations:
#'
#' \if{html}{\figure{fig_height_1.png}{options: width="400"}}
#'
#' \if{html}{\figure{fig_height_2.png}{options: width="400"}}
height <- function(x, i = NULL, height, part = "body", unit = "in"){
  height <- convin(unit = unit, x = height)

  part <- match.arg(part, c("body", "header", "footer"), several.ok = FALSE )

  if( inherits(i, "formula") && any( c("header", "footer") %in% part ) ){
    stop("formula in argument i cannot adress part 'header' or 'footer'.")
  }

  if( nrow_part(x, part ) < 1 ) return(x)

  i <- get_rows_id(x[[part]], i )
  if( !(length(i) == length(height) || length(height) == 1)){
    stop("height should be of length 1 or ", length(i))
  }

  x[[part]]$rowheights[i] <- height

  x
}

#' @export
#' @title Set flextable rule for rows heights
#' @description control rules of each height for a part
#' of the flextable, this is only for Word and PowerPoint outputs, it
#' will not have any effect when output is HTML.
#' @param x flextable object
#' @param i rows selection
#' @param rule specify the meaning of the height. Possible values
#' are "atleast" (height should be at least the value specified), "exact"
#' (height should be exactly the value specified), or the default value "auto"
#' (height is determined based on the height of the contents, so the value is ignored).
#' @param part partname of the table, one of "all", "header", "body", "footer"
#' @examples
#'
#' ft_1 <- flextable(head(iris))
#' ft_1 <- width(ft_1, width = 1.5)
#' ft_1 <- height(ft_1, height = 0.75, part = "header")
#' ft_1 <- hrule(ft_1, rule = "exact", part = "header")
#' ft_1
#'
#' ft_2 <- hrule(ft_1, rule = "auto", part = "header")
#' ft_2
#' @family flextable dimensions
#' @section Illustrations:
#'
#' \if{html}{\figure{fig_hrule_1.png}{options: width="400"}}
#'
#' \if{html}{\figure{fig_hrule_2.png}{options: width="400"}}
hrule <- function(x, i = NULL, rule = "auto", part = "body"){
  part <- match.arg(part, c("body", "header", "footer", "all"), several.ok = FALSE )

  if( "all" %in% part ){
    for(i in c("body", "header", "footer") ){
      x <- hrule(x, rule = rule, part = i)
    }
    return(x)
  }

  if( inherits(i, "formula") && any( c("header", "footer") %in% part ) ){
    stop("formula in argument i cannot adress part 'header' or 'footer'.")
  }

  if( nrow_part(x, part ) < 1 ) return(x)

  i <- get_rows_id(x[[part]], i )
  if( !(length(i) == length(height) || length(height) == 1)){
    stop("height should be of length 1 or ", length(i))
  }

  x[[part]]$hrule[i] <- rule
  x
}


#' @export
#' @rdname height
#' @section height_all:
#' `height_all` is a convenient function for
#' setting the same height to all rows (selected
#' with argument `part`).
#' @examples
#'
#'
#' ft_2 <- flextable(head(iris))
#' ft_2 <- height_all(ft_2, height = 1)
#' ft_2 <- hrule(ft_2, rule = "exact")
#' ft_2
height_all <- function(x, height, part = "all", unit = "in"){
  height <- convin(unit = unit, x = height)

  part <- match.arg(part, c("body", "header", "footer", "all"), several.ok = FALSE )
  if( length(height) != 1 || !is.numeric(height) || height < 0.0 ){
    stop("height should be a single positive numeric value", call. = FALSE)
  }

  if( "all" %in% part ){
    for(i in c("body", "header", "footer") ){

      x <- height_all(x, height = height, part = i)
    }
  }

  if( nrow_part(x, part) > 0 ){
    i <- seq_len(nrow(x[[part]]$dataset))
    x[[part]]$rowheights[i] <- height
  }

  x
}

#' @export
#' @title width and height of a flextable object
#' @description Returns the width, height and
#' aspect ratio of a flextable in a named list.
#' The aspect ratio is the ratio corresponding to `height/width`.
#'
#' Names of the list are `width`, `height` and `aspect_ratio`.
#' @param x a flextable object
#' @param unit unit for returned values, one of "in", "cm", "mm".
#' @examples
#' ftab <- flextable(head(iris))
#' flextable_dim(ftab)
#' ftab <- autofit(ftab)
#' flextable_dim(ftab)
#' @family flextable dimensions
flextable_dim <- function(x, unit = "in"){
  dims <- lapply( dim(x), function(x) convin(unit = unit, x = sum(x)))
  dims$aspect_ratio <- dims$height / dims$width
  dims
}


#' @title Get widths and heights of flextable
#' @description returns widths and heights for each table columns and rows.
#' Values are expressed in inches.
#' @param x flextable object
#' @family flextable dimensions
#' @examples
#' ftab <- flextable(head(iris))
#' dim(ftab)
#' @export
dim.flextable <- function(x){
  max_widths <- list()
  max_heights <- list()
  for(j in c("header", "body", "footer")){
    if( nrow_part(x, j ) > 0 ){
      max_widths[[j]] <- x[[j]]$colwidths
      max_heights[[j]] <- x[[j]]$rowheights
    }
  }

  mat_widths <- do.call("rbind", max_widths)
  if( is.null( mat_widths ) ){
    out_widths <- numeric(0)
  } else {
    out_widths <- apply( mat_widths, 2, max )
    names(out_widths) <- x$col_keys
  }

  out_heights <- as.double(unlist(max_heights))
  list(widths = out_widths, heights = out_heights )
}

#' @export
#' @title Calculate pretty dimensions
#' @description return minimum estimated widths and heights for
#' each table columns and rows in inches.
#' @param x flextable object
#' @param part partname of the table (one of 'all', 'body', 'header' or 'footer')
#' @param unit unit for returned values, one of "in", "cm", "mm".
#' @param .newline_adj logical, adjust size estimates to account for newline chars?  Default FALSE
#' @section line breaks:
#' Soft returns (a line break in a paragraph) are not supported. Function
#' `dim_pretty` will return wrong results if `\n` are used (they will be
#' considered as "").
#' @examples
#' ftab <- flextable(head(mtcars))
#' dim_pretty(ftab)
#' @family flextable dimensions
dim_pretty <- function( x, part = "all", unit = "in", .newline_adj = FALSE){

  part <- match.arg(part, c("all", "body", "header", "footer"), several.ok = TRUE )
  if( "all" %in% part ){
    part <- c("header", "body", "footer")
  }
  dimensions <- list()
  for(j in part){
    if( nrow_part(x, j ) > 0 ){
      dimensions[[j]] <- optimal_sizes(x[[j]], .newline_adj = .newline_adj)
    } else {
      dimensions[[j]] <- list(widths = rep(0, length(x$col_keys) ),
                              heights = numeric(0) )
    }
  }
  widths <- lapply( dimensions, function(x) x$widths )
  widths <- as.numeric(apply( do.call(rbind, widths), 2, max, na.rm = TRUE ))

  heights <- lapply( dimensions, function(x) x$heights )
  heights <- as.numeric(do.call(c, heights))

  list(widths = convin(unit = unit, x = widths), heights = convin(unit = unit, x = heights))
}



#' @export
#' @title Adjusts cell widths and heights
#' @description compute and apply optimized widths and heights
#' (minimum estimated widths and heights for each table columns and rows
#' in inches returned by function [dim_pretty()]).
#'
#' This function is to be used when the table widths and heights
#' should automatically be adjusted to fit the size of the content.
#'
#' @note
#' This function is not related to 'Microsoft Word' *Autofit* feature.
#'
#' @section line breaks:
#' Soft returns (a line break in a paragraph) are not supported. Function
#' `autofit` will return wrong results if `\n` are used (they will be
#' considered as "").
#'
#' @param x flextable object
#' @param add_w extra width to add in inches
#' @param add_h extra height to add in inches
#' @param unit unit for add_h and add_w, one of "in", "cm", "mm".
#' @param part partname of the table (one of 'all', 'body', 'header' or 'footer')
#' @param .newline_adj logical, adjust size estimates to account for newline chars?  Default FALSE
#' @examples
#' ft_1 <- flextable(head(mtcars))
#' ft_1
#' ft_2 <- autofit(ft_1)
#' ft_2
#' @family flextable dimensions
#' @section Illustrations:
#'
#' \if{html}{\figure{fig_autofit_1.png}{options: width="500"}}
#'
#' \if{html}{\figure{fig_autofit_2.png}{options: width="400"}}
autofit <- function(x, add_w = 0.1, add_h = 0.1, part = c("body", "header"),
                    unit = "in", .newline_adj = FALSE){

  add_w <- convin(unit = unit, x = add_w)
  add_h <- convin(unit = unit, x = add_h)

  stopifnot(inherits(x, "flextable") )

  parts <- match.arg(part, c("all", "body", "header", "footer"), several.ok = TRUE )
  if( "all" %in% parts ){
    parts <- c("header", "body", "footer")
  }

  dimensions_ <- dim_pretty(x, part = parts, .newline_adj = .newline_adj)
  names(dimensions_$widths) <- x$col_keys

  nrows <- lapply(parts, function(j){
    nrow_part(x, j )
  } )
  heights <- list(lengths = unlist(nrows), values = parts )
  class(heights) <- "rle"
  heights <- data.frame( part = inverse.rle(heights),
                         height = dimensions_$heights + add_h,
                         stringsAsFactors = FALSE)
  heights <- split(heights$height, heights$part)

  for(j in names(heights)){
    x[[j]]$colwidths <- dimensions_$widths + add_w
    x[[j]]$rowheights <- heights[[j]]
  }
  x
}




#' @importFrom gdtools m_str_extents
optimal_sizes <- function( x, .newline_adj){

  sizes <- text_metric(x, .newline_adj)
  sizes$col_id <- factor(sizes$col_id, levels = x$col_keys)
  sizes <- sizes[order(sizes$col_id, sizes$ft_row_id ), ]
  widths <- as_wide_matrix_(data = sizes[, c("col_id", "width", "ft_row_id")], idvar = "ft_row_id", timevar = "col_id")
  dimnames(widths)[[2]] <- gsub("^width\\.", "", dimnames(widths)[[2]])
  heights <- as_wide_matrix_(data = sizes[, c("col_id", "height", "ft_row_id")], idvar = "ft_row_id", timevar = "col_id")
  dimnames(heights)[[2]] <- gsub("^height\\.", "", dimnames(heights)[[2]])

  par_dim <- dim_paragraphs(x)
  widths <- widths + par_dim$widths
  heights <- heights + par_dim$heights

  widths[x$spans$rows<1] <- 0
  widths[x$spans$columns<1] <- 0
  heights[x$spans$rows<1] <- 0
  heights[x$spans$columns<1] <- 0

  cell_dim <- dim_cells(x)
  widths <- widths + cell_dim$widths
  heights <- heights + cell_dim$heights

  list(widths = apply(widths, 2, max, na.rm = TRUE),
       heights = apply(heights, 1, max, na.rm = TRUE) )
}

#' @importFrom officer table_layout table_width table_colwidths prop_table
#' @export
#' @title Global table properties
#' @description Set table layout and table width. Default to fixed
#' algorithm.
#'
#' If layout is fixed, column widths will be used to display the table;
#' `width` is ignored.
#'
#' If layout is autofit, column widths will not be used;
#' table width is used (as a percentage).
#' @note
#' PowerPoint output ignore 'autofit layout'.
#' @param x flextable object
#' @param layout 'autofit' or 'fixed' algorithm. Default to 'autofit'.
#' @param width The parameter has a different effect depending on the
#' output format. Users should consider it as a minimum width.
#' In HTML, it is the minimum width of the space that the
#' table should occupy. In Word, it is a preferred size and Word
#' may decide not to strictly stick to it. It has no effect on
#' PowerPoint and PDF output. Its default value is 0, as an effect, it
#' only use necessary width to display all content. It is not used by the
#' PDF output.
#' @examples
#' library(flextable)
#' ft_1 <- qflextable(head(cars))
#' ft_2 <- set_table_properties(ft_1, width = .5, layout = "autofit")
#' ft_2
#' @family flextable dimensions
#' @section Illustrations:
#'
#' \if{html}{\figure{fig_set_table_properties_1.png}{options: width="100"}}
#'
#' \if{html}{\figure{fig_set_table_properties_2.png}{options: width="400"}}
set_table_properties <- function(x, layout = "fixed", width = 0){

  stopifnot(layout %in% c("fixed", "autofit"))
  stopifnot(is.numeric(width), width <= 1)

  x$properties <- list(layout = layout, width = width)
  x
}

# utils ----
#' @importFrom stats reshape
as_wide_matrix_ <- function(data, idvar, timevar = "col_key"){
  x <- reshape(data = data, idvar = idvar, timevar = timevar, direction = "wide")
  x[[idvar]] <- NULL
  as.matrix(x)
}


dim_paragraphs <- function(x){
  par_dim <- as.data.frame(x$styles$pars)
  par_dim$width <- as.vector(x$styles$pars[,,"padding.right"] + x$styles$pars[,,"padding.left"]) * (4/3) / 72
  par_dim$height <- as.vector(x$styles$pars[,,"padding.top"] + x$styles$pars[,,"padding.bottom"]) * (4/3) / 72
  selection_ <- c("ft_row_id", "col_id", "width", "height")
  par_dim[, selection_]

  list( widths = as_wide_matrix_( par_dim[,c("col_id", "width", "ft_row_id")], idvar = "ft_row_id", timevar = "col_id" ),
        heights = as_wide_matrix_( par_dim[,c("col_id", "height", "ft_row_id")], idvar = "ft_row_id", timevar = "col_id" )
  )
}

dim_cells <- function(x){
  cell_dim <- as.data.frame(x$styles$cells)
  cell_dim$width <- as.vector(x$styles$cells[,,"margin.right"] + x$styles$cells[,,"margin.left"]) * (4/3) / 72
  cell_dim$height <- as.vector(x$styles$cells[,,"margin.top"] + x$styles$cells[,,"margin.bottom"]) * (4/3) / 72
  selection_ <- c("ft_row_id", "col_id", "width", "height")
  cell_dim <- cell_dim[, selection_]

  cellwidths <- as_wide_matrix_( cell_dim[,c("col_id", "width", "ft_row_id")], idvar = "ft_row_id", timevar = "col_id" )
  cellheights <- as_wide_matrix_( cell_dim[,c("col_id", "height", "ft_row_id")], idvar = "ft_row_id", timevar = "col_id")

  list( widths = cellwidths, heights = cellheights )
}


text_metric <- function( x, .newline_adj){
  txt_data <- fortify_content(x$content, default_chunk_fmt = x$styles$text)

  widths <- txt_data$width
  heights <- txt_data$height
  txt_data$width <- NULL
  txt_data$height <- NULL

  fontsize <- txt_data$font.size
  fontsize[!(txt_data$vertical.align %in% "baseline")] <- fontsize[!(txt_data$vertical.align %in% "baseline")]/2

  if(.newline_adj){

    str_extents_pre1 <-
      mapply(
        FUN = m_str_extents,
        x = strsplit(txt_data$txt, "\n"),
        fontname = txt_data$font.family,
        fontsize = fontsize,
        bold = txt_data$bold,
        italic = txt_data$italic
      )

    str_extents_pre2 <-
      lapply(
        str_extents_pre1,
        function(x){
          w <- max(x[,1]) # Widest of the elements in each set:
          h <- sum(x[,2]) # Sum of heights
          return(matrix(c(w, h), nrow = 1))
        }
      )

    str_extents_ <-
      do.call(rbind, str_extents_pre2) / 72

  } else {

    str_extents_ <-
      m_str_extents(
        x= txt_data$txt,
        fontname = txt_data$font.family,
        fontsize = fontsize,
        bold = txt_data$bold,
        italic = txt_data$italic
      ) / 72
  }

  str_extents_[,1] <- ifelse(is.na(str_extents_[,1]) & !is.null(widths), widths, str_extents_[,1] )
  str_extents_[,2] <- ifelse(is.na(str_extents_[,2]) & !is.null(heights), heights, str_extents_[,2] )
  dimnames(str_extents_) <- list(NULL, c("width", "height"))
  txt_data <- cbind( txt_data, str_extents_ )

  selection_ <- c("ft_row_id", "col_id", "seq_index", "width", "height")
  txt_data <- txt_data[, selection_]
  setDT(txt_data)
  txt_data <- txt_data[, c(list(width=sum(width, na.rm = TRUE), height = max(height, na.rm = TRUE) )),
                       by= c("ft_row_id", "col_id") ]
  setDF(txt_data)
  txt_data
}


